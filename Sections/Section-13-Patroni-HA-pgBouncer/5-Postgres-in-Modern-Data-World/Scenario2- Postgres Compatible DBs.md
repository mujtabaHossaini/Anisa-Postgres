# PostgreSQL Extensions or Protocols: Architecture Roulette

### Should new infrastructure use PostgreSQL as a query engine, or aim for protocol compatibility instead?

[![img](https://substackcdn.com/image/fetch/w_80,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7257377f-ffd3-4455-b305-f2f28f0d31df_1310x1696.png)](https://substack.com/profile/69592459-chris-riccomini)



[PostgreSQL](https://www.postgresql.org/) has a lot of momentum right now. Nearly every startup I talk to is using PostgreSQL or a PostgreSQL-compatible database. Most database vendors offer some form of PostgreSQL compatibility through [extensions](https://www.postgresql.org/docs/current/external-extensions.html), [protocol compatibility](https://www.postgresql.org/docs/current/protocol.html), or [PostgreSQL SQL dialect](https://www.postgresql.org/docs/current/sql-syntax.html) support.

A big part of PostgreSQL’s success is its extension ecosystem. Users no longer need to adopt [Elasticsearch](https://www.elastic.co/elasticsearch) for search, [Pinecone](http://pinecone.io/) for vector search, [Neo4J](https://neo4j.com/) for graph operations, and [Snowflake](https://www.snowflake.com/) for online analytical processing (OLAP). Instead, users are opting for PostgreSQL extensions like [pg_bm25](https://blog.paradedb.com/pages/introducing_bm25), [pgvector](https://github.com/pgvector/pgvector), [postgis](https://postgis.net/), [pg_analytics](https://github.com/paradedb/paradedb/tree/dev/pg_analytics), [hydra_columnar](https://docs.hydra.so/concepts/using-hydra-columnar), and so on. The operational footprint is smaller, users have to deal with fewer (if any) vendors, and PostgreSQL’s architecture is tried-and-true.

Two architectures are emerging. The first embraces PostgreSQL as a query engine to build extensions for. Vendors such as [Hydra](https://www.hydra.so/), [Tembo](https://tembo.io/), [ParadeDB](https://www.paradedb.com/), and [Neon](https://neon.tech/) use this approach. The other approach uses PostgreSQL’s protocols and/or SQL dialect, but builds a new query engine and storage layer from ground up. [CedarDB](https://cedardb.com/), [Yugabyte](https://docs.yugabyte.com/preview/explore/ysql-language-features/postgresql-compatibility/), [CockroachDB](https://www.cockroachlabs.com/docs/stable/postgresql-compatibility), [Spanner](https://cloud.google.com/spanner/docs/postgresql-interface), and [AuroraDB](https://aws.amazon.com/rds/aurora/features) represent the latter approach.

Adopting PostgreSQL as your query engine confers many advantages. You get a lot from PostgreSQL: its excellent [write-ahead log](https://www.postgresql.org/docs/current/wal-intro.html) (WAL), its parser frontend, its network layer, and so on. Infrastructure developers are free to focus only on the area of the system that differentiates their project. Neon, for example, has chosen to focus heavily on the [storage layer](https://neon.tech/docs/introduction/architecture-overview) to provide bottomless storage. In [Postgres is eating the database world](https://medium.com/@fengruohang/postgres-is-eating-the-database-world-157c204dcfc4), [Ruohang Feng](https://twitter.com/GobeUncleWang) writes:

> PostgreSQL is already a near-perfect database kernel for the vast majority of scenarios, making the idea of a kernel “bottleneck” absurd. Forks of PostgreSQL and MySQL that tout kernel modifications as selling points are essentially going nowhere.
>
> This is similar to the situation with the Linux OS kernel today; despite the plethora of Linux distros, everyone opts for the same kernel. Forking the Linux kernel is seen as creating unnecessary difficulties, and the industry frowns upon it.
>
> Accordingly, the main conflict is no longer the database kernel itself but two directions— database **extensions** and **services**! The former pertains to internal extensibility, while the latter relates to external composability. Much like the OS ecosystem, the competitive landscape will concentrate on **database distributions**. In the database domain, only those distributions centered around extensions and services stand a chance for ultimate success.
>
> Kernel remains lukewarm, with MariaDB, the fork of MySQL’s parent, nearing delisting, while AWS, profiting from offering services and extensions on top of the free kernel, thrives. Investment has flowed into numerous PG ecosystem extensions and service distributions: Citus, TimescaleDB, Hydra, PostgresML, ParadeDB, FerretDB, StackGres, Aiven, Neon, Supabase, Tembo, PostgresAI, and our own PG distro — — [Pigsty](https://pigsty.io/).

Feng’s kernel analogy is interesting, as is his comparison between Linux and PostgreSQL distributions. But I think the post misses the significance of PostgreSQL’s protocol being an easy integration point. The question is not whether to package or fork PostgreSQL, but whether to extend PostgreSQL using the extensions API or the protocol.

I disagree with Feng’s statement that, “PostgreSQL is already a near-perfect database kernel for the vast majority of scenarios, making the idea of a kernel “bottleneck” absurd.” Tying yourself to PostgreSQL is always going to be more limiting than building your own database. You’re limited by what PostgreSQL can offer you. The more control you want, the more PostgreSQL is going to feel like a straight jacket. One of Feng’s own examples—Neon—[has had to fork PostgreSQL](https://neon.tech/blog/architecture-decisions-in-neon) to support a remote write-ahead log (something they hope to merge upstream).

And building your own database doesn’t sound as crazy as it used to. Query engine components like [DataFusion](https://arrow.apache.org/datafusion/), [Substrait](https://substrait.io/), and [Velox](https://velox-lib.io/) are maturing. Storage formats like [Parquet](https://parquet.apache.org/) and storage layers like [RocksDB](https://rocksdb.org/) are well known. As I wrote about in [Databases Are Falling Apart: Database Disassembly and Its Implications](https://materializedview.io/p/databases-are-falling-apart), databases are easier than ever to build. Using these systems while maintaining protocol and dialect compatibility with PostgreSQL seems to get you the best of both worlds.

Deployment complexity is still important, though. Extensions are easier to adopt than a new system (with a caveat that I’ll get to in a moment). New infrastructure must justify its upfront adoption cost. Not only must new systems be PostgreSQL compatible, but they must be easier to run and offer more functionality than the PostgreSQL extensions they’re competing with.

Vendors will follow the standard playbook to make their systems easier to run: serverless SaaS, [bring your own cloud](https://thenewstack.io/a-middle-path-for-data-sovereignty-bring-your-own-cloud/) (BYOC), [virtual private clouds](https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html) (VPCs), bring your own object store, and so on.

When it comes to functionality, I believe new databases will need to be [multi-model](https://en.wikipedia.org/wiki/Multi-model_database), something I wrote about in, [Databases Are Commodities. Now What?](https://materializedview.io/p/databases-are-commodities-now-what) Multi-model databases amortize the adoption cost across multiple use cases. Users may choose to keep PostgreSQL as their [online transaction processing](https://en.wikipedia.org/wiki/Online_transaction_processing) (OLTP) system but adopt a single multi-model system for search, GIS, graph, and caching use cases. Multi-model system can take over OLTP workload as users get comfortable with them. [SinleStoreDB](https://www.singlestore.com/) and [CedarDB](https://cedardb.com/) exemplify this approach.

Further pushing users away from extensions is the caveat I alluded to above. The big three cloud providers have limited extension support. Amazon’s Aurora PostgreSQL has an [extensive but not exhaustive](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraPostgreSQLReleaseNotes/AuroraPostgreSQL.Extensions.html) list of supported extensions. The same is true for [Google Cloud’s AlloyDB](https://cloud.google.com/alloydb/docs/reference/extensions). If you want to use an extension that’s not on the list, you’re out of luck. This is an opportunity for third-party providers like Tembo and Neon, and also for multi-model databases that offer missing functionality.

There’s no clear winner between the two architectures. I suspect that both types of systems will exist; indeed, they already do. My gut says that PostgreSQL’s protocol, not its query engine, will be its most defining characteristic. But I also think there’s room in the market for multi-model PostgreSQL vendor distributions.